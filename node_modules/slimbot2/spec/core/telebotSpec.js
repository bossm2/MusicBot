const Bluebird = require('bluebird');
const mockery = require('mockery');
let slimbot2;
let slimbot2;

describe('slimbot2', () => {

  beforeEach(() => {
    mockery.enable({
      warnOnReplace: false,
      warnOnUnregistered: false,
      useCleanCache: true
    });

    mockery.registerMock('request-promise', options => {
      let response = {
        statusCode: 200,
        body: '{ "result": ["test"] }',
        options: options
      };
      return Bluebird.resolve(response);
    });

    slimbot2 = require('../../src/slimbot2');
    slimbot2 = new slimbot2('token');
  });

  afterEach(() => {
    mockery.disable();
    mockery.deregisterAll();
  })

  describe('Core', () => {
    describe('instantiating', () => {
      it('should throw an error if token is not provided', () => {
        expect(() => { const bot = new slimbot2(); }).toThrow();
      });
    });

    describe('_request', () => {
      it('should throw an error if no method provided', done => {
        expect(() => { slimbot2._request(); }).toThrow();
        expect(() => { slimbot2._request(['getMe']); }).toThrow();
        done();
      });

      it('should return a promise', done => {
        expect(typeof slimbot2._request('getUpdates').then === 'function').toEqual(true);
        done();
      });
    });

    describe('_processUpdates', () => {
      let updates;
      let flag;
      let payload;
      beforeEach(() => {
        updates = {
          result: [
            { update_id: 1000, message: 'message' },
            { update_id: 1001, edited_message: 'edited_message' },
            { update_id: 1002, channel_post: 'channel_post' },
            { update_id: 1003, edited_channel_post: 'edited_channel_post' },
            { update_id: 1004, callback_query: 'callback_query' },
            { update_id: 1005, inline_query: 'inline_query' },
            { update_id: 1006, chosen_inline_result: 'chosen_inline_result' },
            { update_id: 1007, shipping_query: 'shipping_query' },
            { update_id: 1008, pre_checkout_query: 'pre_checkout_query' }
          ]
        };
      });

      it('should take the id of last update increased by 1 as offset', () => {
        slimbot2._processUpdates(updates);
        expect(slimbot2._offset).toEqual(1009);
      });

      it('should emit "message" if update is of type "message"', () => {
        slimbot2.on('message', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('message');
      });

      it('should emit "edited_message" if update is of type "edited_message"', () => {
        slimbot2.on('edited_message', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('edited_message');
      });

      it('should emit "channel_post" if update is of type "channel_post"', () => {
        slimbot2.on('channel_post', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('channel_post');
      });

      it('should emit "edited_channel_post" if update is of type "edited_channel_post"', () => {
        slimbot2.on('edited_channel_post', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('edited_channel_post');
      });

      it('should emit "callback_query" if update is of type "callback_query"', () => {
        slimbot2.on('callback_query', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('callback_query');
      });

      it('should emit "inline_query" if update is of type "inline_query"', () => {
        slimbot2.on('inline_query', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('inline_query');
      });

      it('should emit "chosen_inline_result" if update is of type "chosen_inline_result"', () => {
        slimbot2.on('chosen_inline_result', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('chosen_inline_result');
      });

      it('should emit "shipping_query" if update is of type "shipping_query"', () => {
        slimbot2.on('shipping_query', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('shipping_query');
      });

      it('should emit "pre_checkout_query" if update is of type "pre_checkout_query"', () => {
        slimbot2.on('pre_checkout_query', data => {
          if (data !== undefined) {
            flag = true;
            payload = data;
          };
        });
        slimbot2._processUpdates(updates);
        expect(flag).toEqual(true);
        expect(payload).toEqual('pre_checkout_query');
      });

    });
  });

  // slimbot2 API methods

  describe('startPolling', () => {
    it('should call slimbot2._request', () => {
      spyOn(slimbot2, '_request').and.returnValue(Bluebird.resolve());
      slimbot2.startPolling();
      expect(slimbot2._request).toHaveBeenCalled();
    });

    it('should call slimbot2._processUpdates', done => {
      spyOn(slimbot2, '_request').and.returnValue(Bluebird.resolve({}));
      spyOn(slimbot2, '_processUpdates');
      slimbot2.startPolling().then(() => {
        expect(slimbot2._processUpdates).toHaveBeenCalled();
        done();
      });
    });

    it('should store timeout object', done => {
      spyOn(slimbot2, '_request').and.returnValue(Bluebird.resolve({}));
      spyOn(slimbot2, '_processUpdates');
      slimbot2.startPolling().then(() => {
        expect(slimbot2._processUpdates).toHaveBeenCalled();
        expect(slimbot2._timeout).not.toBe(undefined);
        done();
      });
    });
  });

  describe('stopPolling', () => {
    it('should call slimbot2.stopPolling', () => {
      spyOn(slimbot2, 'stopPolling');
      slimbot2.stopPolling();
      expect(slimbot2.stopPolling).toHaveBeenCalled();
      expect(slimbot2._timeout).toBe(undefined);
    });
  });
});